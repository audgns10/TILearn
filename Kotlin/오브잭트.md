# Kotlin -> object

* object

## object

* 코틀린에서 object를 다양한 상황에서 사용하지만 모든 경우 클래스를 정의하면서 동시에 인스턴스를 생성한다는 공통점이 있다

* object 키워드를 사용하는 상황
    1. **객체선언**은 싱글턴을 정의하는 방법 중 하나이다
    2. **동반 객체**는 인스턴스 메서드는 아니지만 어떤 클래스의 관련있는 메서드와 팩토리 메서드를 담을 때 쓰인다 동반 객체 메서드에 접근할 때는 동반 객체가 포함된 클래스의 이름을 사용할 수 있다
    3. **객체 식**은 자바의 무명 내부 클래스 대신 쓰인다

<br>

### 객체 선언 -> 싱글턴

* 객체지향에서 인스턴스가 하나만 필요한 클래스가 유요한 경우가 있는데 자바에서는 보통 클래스의 생성자를 private으로 제한하고 정적인 필드에 클래스의 유일한 객체를 저장하는 싱글턴 패턴을 통해서 이를 구현한다

* 코틀린은 객체 선언 기능을 통해 싱글턴을 언어에서 기본 지원한다. 객체 선언은 클래스 선언과 그 클래스에 속한 단일 인스턴스의 선언을 합친 선언이다.

* 코틀린에서의 객체 선언 예시

```kt
// 객체 선언도 클래스나 인터페이스 상속 사능
// object 키워드를 사용해 클래스 선언과 클래스에 속한 단일 인스턴스의 선언(객체 선언)
// 싱글턴에 해당

import java.io.File
import kotlin.io.path.fileVisitor

object CaseInsensitiveFileComparator: Comparator<File> {
    override fun compare(file1: File, file2: File): Int {
        return file1.path.compareTo(file2.path, ignoreCase = true)
    }
}

fun main() {
    val file1: File = File("/User")
    val file2: File = File("/User")
    // 마침표를 사용하여 객체 선언의 메서드에 접근
    println(CaseInsensitiveFileComparator.compare(file1, file2))

    val files = listOf(file1, file2)
    // 일반 객체를 사용할 수 있는 곳에서 싱글턴 객체 사용 가능
    // Comparator를 인자로 받는 함수에 객체를 전달
    println(files.sortedWith(CaseInsensitiveFileComparator))
}

// 결과
// 0
```

* 객체 선언은 object 키워드로 시작한다
* 객체 선언은 클래스를 정의하고 그 클래스의 인스턴스를 만들어서 변수에 저장하는 모든 작업을 단 한 문장으로 처리한다
* 클래스와 마찬가지로 객체 선언 안에도 프로퍼티, 메서드, 초기화 블록 등이 들어갈 수 있다
* 일반 클래스의 인스턴스와 달리 싱글턴 객체는 객체 선언문이 있는 위치에 생성자 호출 없이 즉시 만들어지기에 생성자는 객체 선언에 쓸 수 없다
* 변수와 마찬가지로 객체 선언에 사용한 이름 뒤에 마침표를 붙이면 객체에 속한 메서드와 ㅍ로퍼티에 접근할 수 있다
* 객체 선언도 클래스나 인터페이스를 상속할 수 있다
* 일반 객체를 사용할 수 있는 곳에서는 항상 싱글턴 